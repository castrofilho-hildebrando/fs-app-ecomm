============================================================
FILE: ./src/infra/repositories/MongoProductRepository.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { Product } from "../models/Product"
    
    export class MongoProductRepository {
        async findById(id: string) {
            const product = await Product.findById(id)
            if (!product) return null
            return {
                id: product._id.toString(),
                _id: product._id.toString(),
                name: product.name,
                price: product.price,
                stock: product.stock,
                description: product.description,
            }
        }
    
        async findByIds(ids: string[]) {
            const products = await Product.find({ _id: { $in: ids } })
            return products.map(p => ({
                id: p._id.toString(),
                _id: p._id.toString(),
                name: p.name,
                price: p.price,
                stock: p.stock,
                description: p.description,
            }))
        }
    
        async decrementStock(productId: string, quantity: number): Promise<void> {
            await Product.updateOne({ _id: productId }, { $inc: { stock: -quantity } })
        }
    
        async findAll() {
            const products = await Product.find()
            return products.map(p => ({
                id: p._id.toString(),
                _id: p._id.toString(),
                name: p.name,
                price: p.price,
                stock: p.stock,
                description: p.description,
            }))
        }
    
        async create(data: { name: string; price: number; stock?: number; description?: string }) {
            const created = await Product.create({
                name: data.name,
                price: data.price,
                stock: data.stock ?? 0,
                description: data.description ?? "",
            })
            return {
                _id: created._id.toString(),
                name: created.name,
                price: created.price,
                stock: created.stock,
                description: created.description,
            }
        }
    
        async update(id: string, data: { name?: string; price?: number; stock?: number; description?: string }) {
            const updated = await Product.findByIdAndUpdate(id, data, { new: true })
            if (!updated) return null
            return {
                _id: updated._id.toString(),
                name: updated.name,
                price: updated.price,
                stock: updated.stock,
                description: updated.description,
            }
        }
    
        async delete(id: string) {
            const res = await Product.findByIdAndDelete(id)
            return !!res
        }
    }

============================================================
FILE: ./src/infra/repositories/MongoCartRepository.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { CartRepository } from "../../application/ports/CartRepository"
    import { Cart } from "../models/Cart"
    
    export class MongoCartRepository implements CartRepository {
    
        async findByUserId(userId: string) {
    
            const cart = await Cart.findOne({ userId }).lean()
    
            if (!cart) {
                return null
            }
    
            return {
                userId: cart.userId.toString(),
                items: cart.items.map(item => ({
                    productId: item.productId.toString(),
                    quantity: item.quantity,
                })),
            }
        }
    
        async addItem(userId: string, productId: string, quantity: number) {
    
            await Cart.updateOne(
                { userId, "items.productId": productId },
                { $inc: { "items.$.quantity": quantity } }
            )
    
            await Cart.updateOne(
                { userId, "items.productId": { $ne: productId } },
                { $push: { items: { productId, quantity } } },
                { upsert: true }
            )
        }
    
        async removeItem(userId: string, productId: string) {
            await Cart.updateOne(
                { userId },
                { $pull: { items: { productId } } }
            )
        }
    
        async clear(userId: string) {
            await Cart.updateOne(
                { userId },
                { $set: { items: [] } }
            )
        }
    }

============================================================
FILE: ./src/infra/repositories/MongoOutboxRepository.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { Outbox } from "../models/Outbox"
    import { OutboxRepository } from "../../application/ports/OutboxRepository"
    import { ApplicationEvent } from "../../application/events/ApplicationEvent"
    
    export class MongoOutboxRepository implements OutboxRepository {
    
        async save(event: ApplicationEvent): Promise<void> {
    
            await Outbox.create({
                name: event.name,
                payload: event.payload,
                occurredAt: event.occurredAt,
                processed: false
            })
        }
    }

============================================================
FILE: ./src/infra/repositories/MongoOrderRepository.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { Order } from "../models/Order"
    import { OrderRepository } from "../../application/ports/OrderRepository"
    
    export class MongoOrderRepository implements OrderRepository {
    
        async save(order: any): Promise<void> {
            await Order.create(order)
        }
    
        async create(order: any): Promise<any> {
            const newOrder = await Order.create(order)
            return {
                id: newOrder._id.toString(),
                userId: newOrder.userId.toString(),
                items: newOrder.items,
                total: newOrder.total,
                status: newOrder.status,
            }
        }
    
        async findByUserId(userId: string) {
            const orders = await Order.find({ userId })
            return orders.map(order => ({
                id: order._id.toString(),
                userId: order.userId.toString(),
                items: order.items,
                total: order.total,
                status: order.status,
            }))
        }
    
        async findById(id: string) {
            const order = await Order.findById(id)
            if (!order) return null
            return {
                id: order._id.toString(),
                userId: order.userId.toString(),
                items: order.items,
                total: order.total,
                status: order.status,
            }
        }
    
        async updateStatus(id: string, status: string) {
            const order = await Order.findByIdAndUpdate(id, { status }, { new: true })
            if (!order) return null
            return {
                id: order._id.toString(),
                userId: order.userId.toString(),
                items: order.items,
                total: order.total,
                status: order.status,
            }
        }
    
        async findAll() {
            const orders = await Order.find()
            return orders.map(o => ({
                id: o._id.toString(),
                userId: o.userId.toString(),
                items: o.items,
                total: o.total,
                status: o.status,
            }))
        }
    }
============================================================
FILE: ./src/infra/eventBus.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { EventBus } from "../domain/events/EventBus"
    import { OrderCreatedEvent } from "../domain/events/OrderCreatedEvent"
    import { SendOrderEmailHandler } from "../application/handlers/SendOrderEmailHandler"
    import { UpdateSalesMetricsHandler } from "../application/handlers/UpdateSalesMetricsHandler"
    
    export const eventBus = new EventBus()
    
    // wiring
    eventBus.subscribe(
    
        OrderCreatedEvent,
        new SendOrderEmailHandler()
    )
    
    eventBus.subscribe(
    
        OrderCreatedEvent,
        new UpdateSalesMetricsHandler()
    )

============================================================
FILE: ./src/infra/models/Outbox.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { Schema, model } from "mongoose"
    
    const OutboxSchema = new Schema(
        {
            name: {
                type: String,
                required: true,
            },
    
            payload: {
                type: Schema.Types.Mixed,
                required: true,
            },
    
            occurredAt: {
                type: Date,
                required: true,
            },
    
            processed: {
                type: Boolean,
                required: true,
                default: false,
            },
    
            processedAt: {
                type: Date,
                required: false,
            },
        },
        {
            timestamps: true,
        }
    )
    
    export const Outbox = model("Outbox", OutboxSchema)

============================================================
FILE: ./src/infra/models/Address.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import mongoose, { Document, Schema } from "mongoose"
    
    // 1. Defini√ß√£o da Interface
    export interface IAddress extends Document {
        userId: mongoose.Types.ObjectId;
        street: string;
        city: string;
        state: string;
        zipCode: string;
        country: string;
        isDefault: boolean;
    }
    
    // 2. Defini√ß√£o do Schema
    const AddressSchema: Schema = new Schema({
        // Refer√™ncia ao usu√°rio
        userId: { type: Schema.Types.ObjectId, ref: "User", required: true, index: true },
        
        street: { type: String, required: true },
        city: { type: String, required: true },
        state: { type: String, required: true },
        zipCode: { type: String, required: true },
        country: { type: String, default: "Brazil" },
        
        // Se este √© o endere√ßo padr√£o do usu√°rio
        isDefault: { type: Boolean, default: false },
    }, {
        timestamps: true 
    })
    
    // 3. Exporta√ß√£o do Modelo
    export const Address = mongoose.model<IAddress>("Address", AddressSchema)
============================================================
FILE: ./src/infra/models/Product.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import mongoose, { Schema, Document } from "mongoose"
    
    export interface IProduct extends Document {
      name: string;
      price: number;
      stock: number;
      description?: string;
    }
    
    const productSchema = new Schema<IProduct>(
        {
            name: { type: String, required: true },
            price: { type: Number, required: true },
            stock: { type: Number, default: 0 },
            description: { type: String, default: "" },
        },
        { timestamps: true }
    )
    
    // üîπ Mongoose sempre cria o campo _id automaticamente
    export const Product = mongoose.model<IProduct>("Product", productSchema)

============================================================
FILE: ./src/infra/models/Cart.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { Schema, model, Document, Types } from "mongoose"
    
    export interface ICart extends Document {
        userId: Types.ObjectId;
        items: { productId: Types.ObjectId; quantity: number }[];
        createdAt: Date;
    }
    
    const CartSchema = new Schema<ICart>({
        userId: { type: Schema.Types.ObjectId, ref: "User", required: true },
        items: [
            {
                productId: {
                    type: Schema.Types.ObjectId,
                    ref: "Product",
                    required: true,
                },
                quantity: { type: Number, required: true },
            },
        ],
        // Adicionado no Schema para criar a data automaticamente
        createdAt: { type: Date, default: Date.now },
    })
    
    export const Cart = model<ICart>("Cart", CartSchema)

============================================================
FILE: ./src/infra/models/Order.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { Schema, model, Document, Types } from "mongoose"
    
    export interface IOrder extends Document {
    
        userId: Types.ObjectId;
        items: { productId: Types.ObjectId; quantity: number }[];
        total: number;
        status: "pending" | "paid" | "shipped" | "completed" | "cancelled";
        createdAt: Date;
    }
    
    const OrderSchema = new Schema<IOrder>({
    
        userId: { type: Schema.Types.ObjectId, ref: "User", required: true },
        items: [
            {
                productId: {
                    type: Types.ObjectId,
                    ref: "Product",
                    required: true,
                },
                quantity: { type: Number, required: true },
            },
        ],
        total: { type: Number, required: true },
        status: {
            type: String,
            enum: ["pending", "paid", "shipped", "completed", "cancelled"],
            default: "pending",
        },
        createdAt: { type: Date, default: Date.now },
    })
    
    export const Order = model<IOrder>("Order", OrderSchema)

============================================================
FILE: ./src/infra/models/User.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { Schema, model, Document } from "mongoose"
    
    export interface IUser extends Document {
        name: string;
        email: string;
        passwordHash: string;
        role: "user" | "admin";
        createdAt: Date;
    }
    
    const UserSchema = new Schema<IUser>({
        name: { type: String, required: true },
        email: { type: String, required: true, unique: true },
        passwordHash: { type: String, select: false, required: true },
        role: { type: String, enum: ["user", "admin"], default: "user" },
        createdAt: { type: Date, default: Date.now },
    })
    
    export const User = model<IUser>("User", UserSchema)

============================================================
FILE: ./src/infra/factories/getCartFactory.ts
LAST_MODIFIED: 2025-12-22 13:43:15
============================================================

    import { GetCartUseCase } from "../../application/usecases/GetCartUseCase"
    import { GetCartUseCaseImpl } from "../../application/usecases/GetCartUseCaseImpl"
    
    import { MongoCartRepository } from "../repositories/MongoCartRepository"
    
    export function makeGetCartUseCase(): GetCartUseCase {
    
        return new GetCartUseCaseImpl(
    
            new MongoCartRepository()
        )
    }
============================================================
FILE: ./src/infra/factories/updateOrderStatusFactory.ts
LAST_MODIFIED: 2025-12-22 13:43:36
============================================================

    import { UpdateOrderStatusUseCase } from "../../application/usecases/UpdateOrderStatusUseCase"
    import { UpdateOrderStatusUseCaseImpl } from "../../application/usecases/UpdateOrderStatusUseCaseImpl"
    
    import { MongoOrderRepository } from "../repositories/MongoOrderRepository"
    
    export function makeUpdateOrderStatusUseCase(): UpdateOrderStatusUseCase {
    
        return new UpdateOrderStatusUseCaseImpl(
    
            new MongoOrderRepository()
        )
    }

============================================================
FILE: ./src/infra/factories/checkoutFactory.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { CheckoutUseCase } from "../../application/usecases/CheckoutUseCase"
    import { CheckoutUseCaseImpl } from "../../application/usecases/CheckoutUseCaseImpl"
    
    import { MongoCartRepository } from "../repositories/MongoCartRepository"
    import { MongoProductRepository } from "../repositories/MongoProductRepository"
    import { MongoOrderRepository } from "../repositories/MongoOrderRepository"
    import { MongoTransactionManager } from "../transaction/MongoTransactionManager"
    import { MongoOutboxRepository } from "../repositories/MongoOutboxRepository"
    
    import { makeClearCartUseCase } from "./clearCartFactory"
    
    export function makeCheckoutUseCase(): CheckoutUseCase {
    
        const cartRepository = new MongoCartRepository()
        const productRepository = new MongoProductRepository()
        const orderRepository = new MongoOrderRepository()
        const transactionManager = new MongoTransactionManager()
        const clearCartUseCase = makeClearCartUseCase()
        const outboxRepository = new MongoOutboxRepository()
    
        return new CheckoutUseCaseImpl(
    
            cartRepository,
            productRepository,
            orderRepository,
            transactionManager,
            clearCartUseCase,
            outboxRepository
        )
    }

============================================================
FILE: ./src/infra/factories/getAllOrdersFactory.ts
LAST_MODIFIED: 2025-12-22 13:42:24
============================================================

    import { GetAllOrdersUseCase } from "../../application/usecases/GetAllOrdersUseCase"
    import { GetAllOrdersUseCaseImpl } from "../../application/usecases/GetAllOrdersUseCaseImpl"
    
    import { MongoOrderRepository } from "../repositories/MongoOrderRepository"
    
    export function makeGetAllOrdersUseCase(): GetAllOrdersUseCase {
    
        return new GetAllOrdersUseCaseImpl(
    
            new MongoOrderRepository()
        )
    }

============================================================
FILE: ./src/infra/factories/removeItemFromCartFactory.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { RemoveItemFromCartUseCase } from "../../application/usecases/RemoveItemFromCartUseCase"
    import { RemoveItemFromCartUseCaseImpl } from "../../application/usecases/RemoveItemFromCartUseCaseImpl"
    
    import { MongoCartRepository } from "../repositories/MongoCartRepository"
    
    export function makeRemoveItemFromCartUseCase(): RemoveItemFromCartUseCase {
        
        const cartRepository = new MongoCartRepository()
    
        return new RemoveItemFromCartUseCaseImpl(
        
            cartRepository
        )
    }

============================================================
FILE: ./src/infra/factories/clearCartFactory.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { ClearCartUseCase } from "../../application/usecases/ClearCartUseCase"
    import { ClearCartUseCaseImpl } from "../../application/usecases/ClearCartUseCaseImpl"
    
    import { MongoCartRepository } from "../repositories/MongoCartRepository"
    
    export function makeClearCartUseCase(): ClearCartUseCase {
    
        return new ClearCartUseCaseImpl(
    
            new MongoCartRepository()
        )
    }

============================================================
FILE: ./src/infra/factories/addItemToCartFactory.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { AddItemToCartUseCase } from "../../application/usecases/AddItemToCartUseCase"
    import { AddItemToCartUseCaseImpl } from "../../application/usecases/AddItemToCartUseCaseImpl"
    
    import { MongoCartRepository } from "../repositories/MongoCartRepository"
    import { MongoProductRepository } from "../repositories/MongoProductRepository"
    
    export function makeAddItemToCartUseCase() {
    
        return new AddItemToCartUseCaseImpl(
    
            new MongoCartRepository(),
            new MongoProductRepository()
        )
    }

============================================================
FILE: ./src/infra/factories/listMyOrdersFactory.ts
LAST_MODIFIED: 2025-12-22 13:43:21
============================================================

    import { ListMyOrdersUseCase } from "../../application/usecases/ListMyOrdersUseCase"
    import { ListMyOrdersUseCaseImpl } from "../../application/usecases/ListMyOrdersUseCaseImpl"
    
    import { MongoOrderRepository } from "../repositories/MongoOrderRepository"
    
    export function makeListMyOrdersUseCase(): ListMyOrdersUseCase {
        return new ListMyOrdersUseCaseImpl(
            new MongoOrderRepository()
        )
    }

============================================================
FILE: ./src/infra/outbox/MongoOutboxDispatcher.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { Outbox } from "../models/Outbox"
    import { OutboxDispatcher } from "./OutboxDispatcher"
    import { OrderPlacedHandler } from "./handlers/OrderPlacedHandler"
    import { ApplicationEvent } from "../../application/events/ApplicationEvent"
    
    type EventHandler = {
        handle(event: ApplicationEvent): Promise<void>;
    };
    
    export class MongoOutboxDispatcher {
    
        private readonly handlers: Record<string, EventHandler> = {
            "order.placed": new OrderPlacedHandler(),
        }
    
        async dispatch(): Promise<void> {
    
            const events = await Outbox.find({
                processed: false,
            })
    
            for (const event of events) {
    
                const handler = this.handlers[event.name]
    
                if (!handler) {
                    // evento desconhecido ‚Üí marcar como processado
                    event.processed = true
                    event.processedAt = new Date()
                    await event.save()
                    continue
                }
    
                await handler.handle({
                    name: event.name,
                    payload: event.payload,
                    occurredAt: event.occurredAt,
                })
    
                event.processed = true
                event.processedAt = new Date()
                await event.save()
            }
        }
    }

============================================================
FILE: ./src/infra/outbox/handlers/OrderPlacedHandler.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { ApplicationEvent } from "../../../application/events/ApplicationEvent"
    
    export class OrderPlacedHandler {
    
        async handle(event: ApplicationEvent): Promise<void> {
    
            const { orderId, userId, total } = event.payload as {
                orderId: string;
                userId: string;
                total: number;
            }
    
            // efeitos colaterais reais
            // ex:
            // await emailService.sendOrderConfirmation(...)
            // await analytics.trackOrder(...)
            // await logger.info(...)
    
            console.log(
                "[OrderPlacedHandler]",
                { orderId, userId, total }
            )
        }
    }

============================================================
FILE: ./src/infra/outbox/OutboxDispatcher.ts
LAST_MODIFIED: 2025-12-22 19:41:43
============================================================

    export interface OutboxDispatcher {
    
        dispatch(): Promise<void>;
    }

============================================================
FILE: ./src/infra/outbox/OutboxCron.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import cron from "node-cron"
    import { MongoOutboxDispatcher } from "./MongoOutboxDispatcher"
    
    const dispatcher = new MongoOutboxDispatcher()
    
    cron.schedule("*/10 * * * * *", async () => {
    
        await dispatcher.dispatch()
    })

============================================================
FILE: ./src/infra/transaction/MongoTransactionManager.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import mongoose from "mongoose"
    import { TransactionManager } from "../../application/ports/TransactionManager"
    
    export class MongoTransactionManager implements TransactionManager {
    
        async runInTransaction<T>(fn: () => Promise<T>): Promise<T> {
            const session = await mongoose.startSession()
            session.startTransaction()
    
            try {
                const result = await fn()
                await session.commitTransaction()
                return result
            } catch (error) {
                await session.abortTransaction()
                throw error
            } finally {
                await session.endSession()
            }
        }
    }

============================================================
FILE: ./src/controllers/authController.ts
LAST_MODIFIED: 2025-12-22 20:16:40
============================================================

    // FILE: ./src/controllers/authController.ts
    
    import { Request, Response } from "express"
    import bcrypt from "bcrypt"
    import jwt from "jsonwebtoken"
    import { User } from "../infra/models/User"
    
    // Importante: O '!' garante ao TypeScript que esta vari√°vel √© uma string definida,
    // j√° que carregamos o .env no server.ts.
    const JWT_SECRET = (process.env.JWT_SECRET || "supersecret") as string 
    
    // =========================================================================
    // REGISTER
    // =========================================================================
    export const registerUser = async (req: Request, res: Response) => {
    
        try {
    
            const { name, email, password } = req.body
    
            if (!name || !email || !password) {
                return res.status(400).json({ error: "Nome, email e senha s√£o obrigat√≥rios" })
            }
    
            const existingUser = await User.findOne({ email })
            if (existingUser) {
                return res.status(409).json({ error: "E-mail j√° registrado" })
            }
    
            // Hashing da senha
            const passwordHash = await bcrypt.hash(password, 10) 
    
            // Cria√ß√£o e salvamento do usu√°rio (role 'user' como padr√£o)
            const newUser = new User({
                name,
                email,
                passwordHash, 
                role: "user",
            })
            await newUser.save()
    
            // Gera√ß√£o do token
            const token = jwt.sign(
                { userId: newUser._id, role: newUser.role },
                JWT_SECRET,
                { expiresIn: "1d" },
            )
    
            // Retorna 201 Created com o token
            // O campo passwordHash √© omitido automaticamente pelo modelo (deve ser, pelo menos)
            res.status(201).json({
                token,
                user: {
                    _id: newUser._id,
                    name: newUser.name,
                    email: newUser.email,
                    role: newUser.role,
                },
            })
        } catch (error) {
            console.error("Erro no registro de usu√°rio:", error)
            res.status(500).json({ error: "Erro interno ao registrar usu√°rio." })
        }
    }
    
    // =========================================================================
    // LOGIN
    // =========================================================================
    export const loginUser = async (req: Request, res: Response) => {
        try {
            const { email, password } = req.body
            
            // 1. Busca o usu√°rio, OBRIGANDO a retornar o passwordHash
            // Se o campo de senha no modelo estiver com `select: false`, esta linha o recupera.
            const user = await User.findOne({ email }).select("+passwordHash")
    
            if (!user) {
                return res.status(401).json({ error: "Credenciais inv√°lidas" })
            }
    
            // 2. Compara a senha (user.passwordHash agora √© garantido)
            // Se user.passwordHash for null/undefined, bcrypt.compare lan√ßa exce√ß√£o (o que causava o 500)
            const isMatch = await bcrypt.compare(password, user.passwordHash || "") // Usamos "" como fallback seguro
    
            if (!isMatch) {
                return res.status(401).json({ error: "Credenciais inv√°lidas" })
            }
    
            // 3. Gera√ß√£o do token
            const token = jwt.sign(
                { userId: user._id, role: user.role },
                JWT_SECRET,
                { expiresIn: "1d" },
            )
    
            res.json({ token, role: user.role })
        } catch (error) {
            console.error("Erro no login (Poss√≠vel falha no bcrypt ou JWT):", error)
            res.status(500).json({ error: "Erro interno do servidor." })
        }
    }
============================================================
FILE: ./src/controllers/adminController.ts
LAST_MODIFIED: 2025-12-29 07:07:49
============================================================

    import { Request, Response } from "express"
    import { User } from "../infra/models/User"
    import { Product } from "../infra/models/Product"
    import { Order } from "../infra/models/Order"
    import { Cart } from "../infra/models/Cart"
    
    export const getStats = async (req: Request, res: Response) => {
    
        try {
    
            const { startDate, endDate } = req.query
            const start = startDate
                ? new Date(startDate as string)
                : new Date("1970-01-01")
            const end = endDate ? new Date(endDate as string) : new Date()
    
            // Filtro de data para todas as queries
            const dateFilter = { createdAt: { $gte: start, $lte: end } }
    
            // 1. Executar todas as consultas independentes em paralelo com Promise.all
            const [users, products, orders, ordersByStatus, carts, topSelling] =
    
                await Promise.all([
    
                    // Usu√°rios
                    User.find(dateFilter),
    
                    // Produtos
                    Product.find(dateFilter),
    
                    // Pedidos
                    Order.find(dateFilter),
    
                    // Pedidos por Status (Aggregation)
                    Order.aggregate([
                        { $match: dateFilter },
                        { $group: { _id: "$status", count: { $sum: 1 } } },
                    ]),
    
                    // Carrinhos
                    Cart.find(dateFilter),
    
                    // Top Selling (Aggregation)
                    Order.aggregate([
                        { $match: dateFilter },
                        { $unwind: "$items" },
                        {
                            $group: {
                                _id: "$items.productId",
                                sold: { $sum: "$items.quantity" },
                            },
                        },
                        { $sort: { sold: -1 } },
                        { $limit: 5 },
                    ]),
                ])
    
            // 2. C√°lculo e processamento dos resultados (Utilizando os dados j√° obtidos)
    
            // Processamento de Usu√°rios
            const totalUsers = users.length
            const admins = users.filter((u) => u.role === "admin").length
            const normalUsers = users.filter((u) => u.role === "user").length
    
            // Processamento de Produtos
            const totalProducts = products.length
    
            // Processamento de Pedidos
            const totalOrders = orders.length
            const revenueTotal = orders.reduce((acc, o) => acc + o.total, 0)
            const avgTicket = totalOrders > 0 ? revenueTotal / totalOrders : 0
    
            // Processamento de Carrinhos
            const avgItems =
                carts.length > 0
                    ? carts.reduce((acc, c) => acc + c.items.length, 0) /
                      carts.length
                    : 0
            const conversionRate =
                carts.length > 0 ? totalOrders / carts.length : 0
    
            // 3. Resposta Final
            res.json({
    
                period: { start, end },
                users: { total: totalUsers, admins, users: normalUsers },
                products: { total: totalProducts, topSelling },
                orders: {
                    total: totalOrders,
                    revenueTotal,
                    avgTicket,
                    byStatus: ordersByStatus,
                },
                carts: { avgItems, conversionRate },
            })
        }
    
        catch {
    
            res.status(500).json({
                error: "Erro ao gerar estat√≠sticas consolidadas",
            })
        }
    }

============================================================
FILE: ./src/controllers/orderController.ts
LAST_MODIFIED: 2025-12-29 15:23:26
============================================================

    import { Request, Response } from "express"
    import { makeCheckoutUseCase } from "../infra/factories/checkoutFactory"
    import { makeGetAllOrdersUseCase } from "../infra/factories/getAllOrdersFactory"
    import { MongoOrderRepository } from "../infra/repositories/MongoOrderRepository"
    
    const orderRepository = new MongoOrderRepository()
    
    export async function checkout(req: Request, res: Response) {
    
        try {
    
            const user = req.user
            if (!user) return res.status(401).json({ message: "Unauthorized" })
    
            const checkoutUseCase = makeCheckoutUseCase()
            const result = await checkoutUseCase.execute({ userId: user.userId })
    
            return res.status(201).json({
                order: {
                    _id: result.orderId,
                    status: result.status,
                    total: result.total,
                },
            })
        }
    
        catch (error: any) {
            const code = error?.code
            const known = ["CART_EMPTY", "PRODUCT_NOT_FOUND", "INSUFFICIENT_STOCK"]
            const status = known.includes(code) ? 400 : 500
            return res.status(status).json({ error: error.message })
        }
    }
    
    // Exportando createOrder para a rota POST /
    export const createOrder = checkout
    
    export async function updateOrderStatus(req: Request, res: Response) {
    
        try {
    
            const user = req.user
            if (!user || user.role !== "admin") return res.status(403).json({ message: "Forbidden" })
    
            const { id } = req.params
            if (!id) {
    
                return res.status(400).json({ message: "Product id is required" })
            }
    
            const { status } = req.body
            const updatedOrder = await orderRepository.updateStatus(id, status)
    
            if (!updatedOrder) {
    
                return res.status(404).json({ message: "Order not found" })
            }
    
            const newOrderStatus = {
                _id: updatedOrder.id,
                status: updatedOrder.status,
                total: updatedOrder.total,
            }
    
            return res.status(200).json(newOrderStatus)
        }
    
        catch {
            return res.status(500).json({ error: "Erro interno" })
        }
    }
    
    export async function getMyOrders(req: Request, res: Response) {
        try {
            const user = req.user
            if (!user) return res.status(401).json({ message: "Unauthorized" })
    
            const orders = await orderRepository.findByUserId(user.userId)
            return res.status(200).json(orders.map(o => ({ ...o, _id: o.id })))
        } catch {
            return res.status(500).json({ error: "Erro interno" })
        }
    }
    
    export async function getAllOrders(req: Request, res: Response) {
        try {
            const user = req.user
            if (!user || user.role !== "admin") return res.status(403).json({ message: "Forbidden" })
    
            const useCase = makeGetAllOrdersUseCase()
            const orders = await useCase.execute({ actor: { id: user.userId, role: user.role } })
            return res.status(200).json(orders)
        } catch (error: any) {
            return res.status(403).json({ message: error.message })
        }
    }
============================================================
FILE: ./src/controllers/cartController.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { Request, Response } from "express"
    import { makeGetCartUseCase } from "../infra/factories/getCartFactory"
    import { makeAddItemToCartUseCase } from "../infra/factories/addItemToCartFactory"
    import { makeRemoveItemFromCartUseCase } from "../infra/factories/removeItemFromCartFactory"
    import { makeClearCartUseCase } from "../infra/factories/clearCartFactory"
    
    export const getCart = async (req: Request, res: Response) => {
        try {
            const userId = req.user?.userId
            if (!userId) return res.status(401).json({ error: "N√£o autorizado" })
    
            const useCase = makeGetCartUseCase()
            const cart = await useCase.execute({ userId }) // objeto!
            // testes esperam items na raiz
            return res.status(200).json({ items: cart.items })
        } catch (error: any) {
            return res.status(500).json({ error: error.message })
        }
    }
    
    export const addItemToCart = async (req: Request, res: Response) => {
        try {
            const userId = req.user?.userId
            const { productId, quantity } = req.body
    
            if (!userId) return res.status(401).json({ error: "N√£o autorizado" })
            if (!productId || !quantity) {
                return res.status(400).json({ error: "Produto e quantidade s√£o obrigat√≥rios" })
            }
    
            const useCase = makeAddItemToCartUseCase()
            await useCase.execute({ userId, productId, quantity }) // objeto!
    
            const getUseCase = makeGetCartUseCase()
            const updatedCart = await getUseCase.execute({ userId })
    
            return res.status(200).json({ cart: updatedCart })
        }
    
        catch (error: any) {
    
            const code = error?.code
            const status = code === "PRODUCT_NOT_FOUND" ? 404 : 400
            return res.status(status).json({ error: error.message })
        }
    }
    
    export const removeItemFromCart = async (req: Request, res: Response) => {
    
        try {
            const userId = req.user?.userId
            const { productId } = req.body // ler do body
    
            if (!userId) return res.status(401).json({ error: "N√£o autorizado" })
    
            // checar exist√™ncia do carrinho antes
            const getUseCase = makeGetCartUseCase()
            const existing = await getUseCase.execute({ userId })
            if (!existing || existing.items.length === 0) {
                return res.status(404).json({ error: "Carrinho n√£o existe" })
            }
    
            const useCase = makeRemoveItemFromCartUseCase()
            await useCase.execute({ userId, productId })
    
            const updatedCart = await getUseCase.execute({ userId })
    
            return res.status(200).json({ cart: updatedCart })
        } catch (error: any) {
            return res.status(500).json({ error: error.message })
        }
    }
    
    
    export const clearCart = async (req: Request, res: Response) => {
        try {
            const userId = req.user?.userId
            if (!userId) return res.status(401).json({ error: "N√£o autorizado" })
    
            const getUseCase = makeGetCartUseCase()
            const existing = await getUseCase.execute({ userId })
            if (!existing || existing.items.length === 0) {
                return res.status(404).json({ error: "Carrinho n√£o existe" })
            }
    
            const useCase = makeClearCartUseCase()
            await useCase.execute({ userId })
    
            return res.status(200).json({ message: "Carrinho limpo com sucesso", cart: { items: [] } })
        } catch (error: any) {
            return res.status(500).json({ error: error.message })
        }
    }

============================================================
FILE: ./src/controllers/addressController.ts
LAST_MODIFIED: 2025-12-29 07:01:20
============================================================

    import { Request, Response } from "express"
    import { Address } from "../infra/models/Address"
    import mongoose from "mongoose"
    
    // Fun√ß√£o auxiliar para garantir que apenas um endere√ßo seja o padr√£o
    const ensureOnlyOneDefault = async (userId: mongoose.Types.ObjectId, currentAddressId?: mongoose.Types.ObjectId) => {
    
        // Define todos os outros endere√ßos (exceto o atual, se fornecido) como n√£o-padr√£o
        const filter: any = { userId }
        if (currentAddressId) {
    
            filter._id = { $ne: currentAddressId }
        }
    
        await Address.updateMany(filter, { isDefault: false })
    }
    
    // =========================================================================
    // POST /api/addresses - Criar novo endere√ßo
    // =========================================================================
    export const createAddress = async (req: Request, res: Response) => {
    
        try {
    
            const userId = req.user?.userId
            if (!userId) {
    
                return res.status(401).json({ error: "Usu√°rio n√£o autenticado." })
            }
    
            const { street, city, state, zipCode, country, isDefault } = req.body
    
            if (!street || !city || !state || !zipCode) {
    
                return res.status(400).json({ error: "Campos obrigat√≥rios ausentes." })
            }
    
            const addressData = {
                userId,
                street,
                city,
                state,
                zipCode,
                country,
                isDefault: isDefault === true,
            }
    
            if (addressData.isDefault) {
    
                await ensureOnlyOneDefault(new mongoose.Types.ObjectId(userId))
            }
    
            const newAddress = new Address(addressData)
            await newAddress.save()
            
            res.status(201).json({ message: "Endere√ßo criado com sucesso", address: newAddress })
        }
    
        catch (error) {
    
            console.error("Erro ao criar endere√ßo:", error)
            res.status(500).json({ error: "Erro interno ao criar endere√ßo." })
        }
    }
    
    // =========================================================================
    // GET /api/addresses - Listar todos os endere√ßos do usu√°rio
    // =========================================================================
    export const getAddresses = async (req: Request, res: Response) => {
    
        try {
    
            const userId = req.user?.userId
            if (!userId) {
    
                return res.status(401).json({ error: "Usu√°rio n√£o autenticado." })
            }
    
            const addresses = await Address.find({ userId }).sort({ isDefault: -1, createdAt: 1 })
            
            res.json(addresses)
        }
    
        catch (error) {
    
            console.error("Erro ao buscar endere√ßos:", error)
            res.status(500).json({ error: "Erro interno ao buscar endere√ßos." })
        }
    }
    
    // =========================================================================
    // PUT /api/addresses/:id - Atualizar endere√ßo
    // =========================================================================
    export const updateAddress = async (req: Request, res: Response) => {
    
        try {
    
            const userId = req.user?.userId
            if (!userId) return res.status(401).json({ error: "Usu√°rio n√£o autenticado." })
    
            const { id } = req.params
            const updateData = req.body
            
            // Garante que o usu√°rio s√≥ pode atualizar seus pr√≥prios endere√ßos
            const objectId = new mongoose.Types.ObjectId(id)
            const objectUserId = new mongoose.Types.ObjectId(userId)
    
            const address = await Address.findOne({ _id: objectId, userId: objectUserId })
            if (!address) {
    
                return res.status(404).json({ error: "Endere√ßo n√£o encontrado ou n√£o pertence ao usu√°rio." })
            }
    
            if (updateData.isDefault === true) {
    
                await ensureOnlyOneDefault(new mongoose.Types.ObjectId(userId), new mongoose.Types.ObjectId(id))
            }
    
            const updatedAddress = await Address.findByIdAndUpdate(id, updateData, { new: true })
            
            res.json({ message: "Endere√ßo atualizado com sucesso", address: updatedAddress })
        }
    
        catch (error) {
    
            console.error("Erro ao atualizar endere√ßo:", error)
            res.status(500).json({ error: "Erro interno ao atualizar endere√ßo." })
        }
    }
    
    // =========================================================================
    // DELETE /api/addresses/:id - Deletar endere√ßo
    // =========================================================================
    export const deleteAddress = async (req: Request, res: Response) => {
    
        try {
    
            const userId = req.user?.userId
            if (!userId) {
    
                return res.status(401).json({ error: "Usu√°rio n√£o autenticado." })
            }
    
            const { id } = req.params
    
            const objectId = new mongoose.Types.ObjectId(id)
            const objectUserId = new mongoose.Types.ObjectId(userId)
            
            // Garante que o usu√°rio s√≥ pode deletar seus pr√≥prios endere√ßos
            const deletedAddress = await Address.findOneAndDelete({ _id: objectId, userId: objectUserId })
            
            if (!deletedAddress) {
    
                return res.status(404).json({ error: "Endere√ßo n√£o encontrado ou n√£o pertence ao usu√°rio." })
            }
            
            res.json({ message: "Endere√ßo removido com sucesso" })
        }
    
        catch (error) {
    
            console.error("Erro ao deletar endere√ßo:", error)
            res.status(500).json({ error: "Erro interno ao deletar endere√ßo." })
        }
    }
============================================================
FILE: ./src/controllers/userController.ts
LAST_MODIFIED: 2025-12-22 20:16:59
============================================================

    import { Request, Response } from "express"
    import { User } from "../infra/models/User"
    
    export const getAllUsers = async (req: Request, res: Response) => {
        try {
            const users = await User.find().select("-passwordHash")
            res.json(users)
        } catch (error) {
            res.status(500).json({ error: "Erro ao listar usu√°rios" })
        }
    }
    
    export const getUserById = async (req: Request, res: Response) => {
        try {
            const user = await User.findById(req.params.id).select("-passwordHash")
            if (!user)
                return res.status(404).json({ error: "Usu√°rio n√£o encontrado" })
    
            res.json(user)
        } catch (error) {
            res.status(500).json({ error: "Erro ao buscar usu√°rio" })
        }
    }
    
    export const updateUser = async (req: Request, res: Response) => {
        try {
            const updatedUser = await User.findByIdAndUpdate(
                req.params.id,
                req.body,
                { new: true },
            ).select("-passwordHash")
            if (!updatedUser)
                return res.status(404).json({ error: "Usu√°rio n√£o encontrado" })
    
            res.json({
                message: "Usu√°rio atualizado com sucesso!",
                user: updatedUser,
            })
        } catch (error) {
            res.status(500).json({ error: "Erro ao atualizar usu√°rio" })
        }
    }
    
    export const deleteUser = async (req: Request, res: Response) => {
        try {
            const deletedUser = await User.findByIdAndDelete(req.params.id)
            if (!deletedUser)
                return res.status(404).json({ error: "Usu√°rio n√£o encontrado" })
    
            res.json({ message: "Usu√°rio removido com sucesso!" })
        } catch (error) {
            res.status(500).json({ error: "Erro ao remover usu√°rio" })
        }
    }

============================================================
FILE: ./src/controllers/productController.ts
LAST_MODIFIED: 2025-12-29 15:24:35
============================================================

    import { Request, Response } from "express"
    import { MongoProductRepository } from "../infra/repositories/MongoProductRepository"
    
    const productRepository = new MongoProductRepository()
    
    // GET /api/products ‚Äî rota p√∫blica
    export async function getAllProducts(req: Request, res: Response) {
        try {
            const products = await productRepository.findAll()
            return res.status(200).json(products)   // üîπ j√° vem com _id
        } catch (error) {
            console.error("GET PRODUCTS ERROR:", error)
            return res.status(500).json({ error: "Erro interno" })
        }
    }
    
    export async function createProduct(req: Request, res: Response) {
        try {
            const user = req.user
            if (!user) return res.status(401).json({ message: "Unauthorized" })
            if (user.role !== "admin") return res.status(403).json({ message: "Forbidden" })
    
            const { name, price, stock, description } = req.body
            if (!name || price === undefined) {
                return res.status(400).json({ error: "Campos obrigat√≥rios: name e price" })
            }
    
            const created = await productRepository.create({
                name,
                price,
                stock: stock ?? 0,
                description: description ?? "",
            })
    
            // üîπ garantir que _id esteja presente no objeto retornado
            return res.status(201).json({
                product: {
                    _id: created._id,
                    name: created.name,
                    price: created.price,
                    stock: created.stock,
                    description: created.description,
                }
            })
        } catch (error) {
            console.error("CREATE PRODUCT ERROR:", error)
            return res.status(500).json({ error: "Erro interno" })
        }
    }
    
    export async function updateProduct(req: Request, res: Response) {
    
        try {
    
            const user = req.user
    
            if (!user) {
    
                return res.status(401).json({ message: "Unauthorized" })
            }
    
            if (user.role !== "admin") {
    
                return res.status(403).json({ message: "Forbidden" })
            }
    
            const { id } = req.params
            if (!id) {
    
                return res.status(400).json({ message: "Product id is required" })
            }
    
            const { name, price, stock, description } = req.body
    
            const updated = await productRepository.update(id, {
                name,
                price,
                stock,
                description,
            })
    
            if (!updated) return res.status(404).json({ message: "Produto n√£o encontrado" })
    
            // üîπ garantir que _id esteja presente
            return res.status(200).json({
                product: {
                    _id: updated._id,
                    name: updated.name,
                    price: updated.price,
                    stock: updated.stock,
                    description: updated.description,
                }
            })
        }
    
        catch (error) {
            console.error("UPDATE PRODUCT ERROR:", error)
            return res.status(500).json({ error: "Erro interno" })
        }
    }
    
    // DELETE /api/products/:id ‚Äî apenas admin
    export async function deleteProduct(req: Request, res: Response) {
        try {
            const user = req.user
            if (!user) return res.status(401).json({ message: "Unauthorized" })
            if (user.role !== "admin") return res.status(403).json({ message: "Forbidden" })
    
            const { id } = req.params
            if (!id) {
    
                return res.status(400).json({ message: "Product id is required" })
            }
    
            const deleted = await productRepository.delete(id)
    
            if (!deleted) return res.status(404).json({ message: "Produto n√£o encontrado" })
    
            // üîπ manter consist√™ncia: resposta dentro de product
            return res.status(200).json({ product: { deleted: true, _id: id } })
        } catch (error) {
            console.error("DELETE PRODUCT ERROR:", error)
            return res.status(500).json({ error: "Erro interno" })
        }
    }
    

============================================================
FILE: ./src/utils/logger.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    // FILE: src/utils/logger.ts
    
    /**
     * N√≠veis de severidade de log.
     */
    type LogLevel = "INFO" | "WARN" | "ERROR" | "DEBUG";
    
    /**
     * Fun√ß√£o de log simples e formatada.
     * Ideal para logs no servidor, adicionando timestamps e n√≠veis.
     * * @param level O n√≠vel de severidade da mensagem.
     * @param message A mensagem principal a ser logada.
     * @param details (Opcional) Detalhes adicionais, como um objeto de erro.
     */
    export const log = (
        level: LogLevel,
        message: string,
        details?: any
    ) => {
        // 1. Defini√ß√£o do carimbo de data/hora (Timestamp)
        const timestamp = new Date().toISOString()
    
        // 2. Formata√ß√£o da mensagem principal
        const logMessage = `[${timestamp}] [${level}] - ${message}`
    
        // 3. Escolha do console method baseado no n√≠vel
        const consoleMethod = 
            level === "ERROR" ? console.error :
                level === "WARN" ? console.warn :
                    console.log // INFO ou DEBUG
    
        // 4. Exibir o log
        if (details) {
            // Se houver detalhes, loga a mensagem e os detalhes no console
            consoleMethod(logMessage, details)
        } else {
            // Se n√£o houver detalhes, loga apenas a mensagem
            consoleMethod(logMessage)
        }
    
        // Nota: Em um ambiente real, voc√™ faria aqui:
        // - Envio para um servi√ßo de monitoramento (e.g., Sentry, DataDog).
        // - Escrita em um arquivo de log (File System).
    }
    
    // Exemplo de uso
    // log('INFO', 'Servidor inicializado com sucesso.');
    // log('ERROR', 'Falha ao conectar ao DB', new Error('Connection refused'));
============================================================
FILE: ./src/server.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import mongoose from "mongoose"
    import { config } from "dotenv"
    import app from "./app"
    
    config()
    
    const PORT = process.env.PORT || 4000
    
    mongoose
        .connect(process.env.MONGO_URI as string)
        .then(() => {
            console.log("Conectado ao MongoDB Atlas")
            app.listen(PORT, () => {
                console.log(`Servidor rodando na porta ${PORT}`)
            })
        })
        .catch((err) => {
            console.error("Erro ao conectar ao MongoDB:", err)
        })

============================================================
FILE: ./src/domain/types/ProductSnapshot.ts
LAST_MODIFIED: 2025-12-19 15:56:09
============================================================

    export type ProductSnapshot = {
        id: string;
        price: number;
        stock: number;
    };

============================================================
FILE: ./src/domain/types/OrderItem.ts
LAST_MODIFIED: 2025-12-19 16:22:37
============================================================

    export type OrderItem = {
        productId: string;
        quantity: number;
    };

============================================================
FILE: ./src/domain/errors/InvalidStatusTransactionError.ts
LAST_MODIFIED: 2025-12-29 15:52:22
============================================================

    import { DomainError } from "./DomainError"
    
    export class InvalidStatusTransactionError extends DomainError {
    
        constructor(code: string, message: string = "Access denied") {
    
            super(code, message)
        }
    }

============================================================
FILE: ./src/domain/errors/OrderCannotBeCancelledError.ts
LAST_MODIFIED: 2025-12-29 15:49:54
============================================================

    import { DomainError } from "./DomainError"
    
    export class OrderCannotBeCancelledError extends DomainError {
    
        constructor(code: string, message: string = "Access denied") {
    
            super(code, message)
        }
    }

============================================================
FILE: ./src/domain/errors/OrderWithoutItemsError.ts
LAST_MODIFIED: 2025-12-29 15:51:00
============================================================

    import { DomainError } from "./DomainError"
    
    export class OrderWithoutItemsError extends DomainError {
    
        constructor(code: string, message: string = "Access denied") {
    
            super(code, message)
        }
    }

============================================================
FILE: ./src/domain/errors/DomainError.ts
LAST_MODIFIED: 2025-12-29 15:43:33
============================================================

    export abstract class DomainError extends Error {
    
        public readonly code: string
    
        constructor(code: string, message: string) {
    
            super(message)
            this.code = code
            this.name = this.constructor.name
        }
    }

============================================================
FILE: ./src/domain/errors/OrderNotFoundError.ts
LAST_MODIFIED: 2025-12-29 15:50:27
============================================================

    import { DomainError } from "./DomainError"
    
    export class OrderNotFoundError extends DomainError {
    
        constructor(code: string, message: string = "Order not found") {
    
            super(code, message)
        }
    }

============================================================
FILE: ./src/domain/errors/CheckoutErrors.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { DomainError } from "./DomainError"
    
    export class CartEmptyError extends DomainError {
        constructor() {
            super("CART_EMPTY", "Carrinho vazio")
            this.name = "CartEmptyError"
        }
    }
    
    export class ProductNotFoundError extends DomainError {
        constructor(productId?: string) {
            super(
                "PRODUCT_NOT_FOUND",
                productId ? `Produto ${productId} n√£o encontrado` : "Produto n√£o encontrado"
            )
            this.name = "ProductNotFoundError"
        }
    }
    
    export class InsufficientStockError extends DomainError {
        constructor(productId: string, available: number, requested: number) {
            super(
                "INSUFFICIENT_STOCK",
                `Estoque insuficiente para o produto ${productId}. Dispon√≠vel: ${available}, solicitado: ${requested}`
            )
            this.name = "InsufficientStockError"
        }
    }

============================================================
FILE: ./src/domain/errors/AccessDeniedError.ts
LAST_MODIFIED: 2025-12-29 15:48:27
============================================================

    import { DomainError } from "./DomainError"
    
    export class AccessDeniedError extends DomainError {
    
        constructor(code: string, message: string = "Access denied") {
    
            super(code, message)
        }
    }

============================================================
FILE: ./src/domain/errors/CartNotFoundError.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    export class CartNotFoundError extends Error {
    
        public readonly userId: string
    
        constructor(userId: string) {
            super(`Cart not found for user ${userId}`)
            this.name = "CartNotFoundError"
            this.userId = userId
        }
    }
    

============================================================
FILE: ./src/domain/errors/InvalidErrorTotalError.ts
LAST_MODIFIED: 2025-12-29 15:48:58
============================================================

    import { DomainError } from "./DomainError"
    
    export class InvalidErrorTotalError extends DomainError {
    
        constructor(code: string, message:string = "Access denied") {
    
            super(code, message)
        }
    }

============================================================
FILE: ./src/domain/errors/ProductNotFoundError.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    export class ProductNotFoundError extends Error {
        public readonly productId: string
        public readonly code = "PRODUCT_NOT_FOUND"
    
        constructor(productId: string) {
            super(`Produto ${productId} n√£o encontrado`)
            this.name = "ProductNotFoundError"
            this.productId = productId
        }
    }

============================================================
FILE: ./src/domain/errors/OnlyAdminCanChangeOrderStatusError.ts
LAST_MODIFIED: 2025-12-29 15:55:38
============================================================

    import { DomainError } from "./DomainError"
    
    export class OnlyAdminCanChangeOrderStatusError extends DomainError {
    
        constructor(code: string, message:string = "Access denied") {
    
            super(code, message)
        }
    }

============================================================
FILE: ./src/domain/events/DomainEventHandler.ts
LAST_MODIFIED: 2025-12-17 19:30:10
============================================================

    export interface DomainEventHandler<T> {
        handle(event: T): Promise<void> | void;
    }

============================================================
FILE: ./src/domain/events/EventBus.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { DomainEventHandler } from "./DomainEventHandler"
    
    type EventClass<T> = new (...args: any[]) => T;
    
    export class EventBus {
    
        private handlers = new Map<string, DomainEventHandler<any>[]>()
    
        subscribe<T extends object>(
            event: EventClass<T>,
            handler: DomainEventHandler<T>
        ) {
    
            const eventName = event.name
    
            const existing = this.handlers.get(eventName) ?? []
            existing.push(handler)
    
            this.handlers.set(eventName, existing)
        }
    
        async publish<T extends object>(event: T) {
    
            const eventName = event.constructor.name
            const handlers = this.handlers.get(eventName) ?? []
    
            for (const handler of handlers) {
                await handler.handle(event)
            }
        }
    }

============================================================
FILE: ./src/domain/events/OrderCreatedEvent.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    export class OrderCreatedEvent {
    
        readonly occurredAt: Date
    
        constructor(
            public readonly orderId: string,
            public readonly userId: string,
            public readonly total: number
        ) {
    
            this.occurredAt = new Date()
        }
    }

============================================================
FILE: ./src/domain/services/OrderStatusDomainService.ts
LAST_MODIFIED: 2025-12-29 15:57:38
============================================================

    import { InvalidStatusTransactionError } from "../errors/InvalidStatusTransactionError"
    import { OnlyAdminCanChangeOrderStatusError } from "../errors/OnlyAdminCanChangeOrderStatusError"
    
    const allowedTransitions: Record<string, string[]> = {
        pending: ["paid"],
        paid: ["shipped"],
        shipped: ["delivered"],
    }
    
    export class OrderStatusDomainService {
    
        validateTransition(
            currentStatus: string,
            newStatus: string
        ) {
            const allowed = allowedTransitions[currentStatus] || []
    
            if (!allowed.includes(newStatus)) {
                throw new InvalidStatusTransactionError(
                    'INVALID_STATUS_TRANSACTION', `Invalid status transition from ${currentStatus} to ${newStatus}`
                )
            }
        }
    
        validatePermission(
            actorRole: "admin" | "user",
            currentStatus: string,
            newStatus: string
        ) {
            if (actorRole !== "admin") {
                throw new OnlyAdminCanChangeOrderStatusError("ONLY_ADMIN_CAN_CHANGE_ORDER_STATUS", "Only admin can change order status")
            }
        }
    }

============================================================
FILE: ./src/domain/services/OrderValidationService.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { OrderItem } from "../types/OrderItem"
    import { ProductSnapshot } from "../types/ProductSnapshot"
    import { ProductNotFoundError, InsufficientStockError } from "../errors/CheckoutErrors"
    
    export class OrderValidationService {
        validateAndCalculateTotal(items: OrderItem[], products: ProductSnapshot[]): number {
            const productMap: Record<string, ProductSnapshot> = {}
            for (const product of products) {
                productMap[product.id] = product
            }
    
            let total = 0
    
            for (const item of items) {
                const product = productMap[item.productId]
    
                if (!product) {
                    throw new ProductNotFoundError(item.productId)
                }
    
                if (product.stock < item.quantity) {
                    throw new InsufficientStockError(item.productId, product.stock, item.quantity)
                }
    
                total += product.price * item.quantity
            }
    
            return total
        }
    }

============================================================
FILE: ./src/domain/entities/Order.ts
LAST_MODIFIED: 2025-12-29 15:41:49
============================================================

    import { OrderWithoutItemsError } from "../errors/OrderWithoutItemsError"
    import { InvalidErrorTotalError } from "../errors/InvalidErrorTotalError"
    import { InvalidStatusTransactionError } from "../errors/InvalidStatusTransactionError"
    import { OrderCannotBeCancelledError } from "../errors/OrderCannotBeCancelledError"
    
    export type OrderStatus =
      | "pending"
      | "paid"
      | "shipped"
      | "completed"
      | "cancelled";
    
    export interface OrderItem {
        productId: string;
        quantity: number;
    }
    
    export class Order {
    
        private _status: OrderStatus
    
        private readonly _items: OrderItem[]
    
        private readonly _total: number
    
        constructor(
    
            status: OrderStatus,
            items: OrderItem[],
            total: number
        ) {
    
            if (items.length === 0) {
    
                throw new OrderWithoutItemsError("ORDER_WITHOUT_ITEMS")
            }
    
            if (total <= 0) {
    
                throw new InvalidErrorTotalError("INVALID_ORDER_TOTAL")
            }
    
            this._status = status
            this._items = items
            this._total = total
        }
    
        // =====================
        // Getters
        // =====================
    
        get status() {
    
            return this._status
        }
    
        get total() {
    
            return this._total
        }
    
        get items() {
    
            return [...this._items]
        }
    
        // =====================
        // Comportamentos
        // =====================
    
        markAsPaid() {
    
            if (this._status !== "pending") {
    
                throw new InvalidStatusTransactionError(
    
                    "INVALID_STATUS_TRANSITION",
                    `Cannot pay order in status ${this._status}`
                )
            }
    
            this._status = "paid"
        }
    
        ship() {
    
            if (this._status !== "paid") {
    
                throw new InvalidStatusTransactionError(
    
                    "INVALID_STATUS_TRANSITION",
                    `Cannot ship order in status ${this._status}`
                )
            }
    
            this._status = "shipped"
        }
    
        complete() {
    
            if (this._status !== "shipped") {
    
                throw new InvalidStatusTransactionError(
    
                    "INVALID_STATUS_TRANSITION",
                    `Cannot complete order in status ${this._status}`
                )
            }
    
            this._status = "completed"
        }
    
    
        cancel() {
    
            if (this._status === "shipped") {
    
                throw new OrderCannotBeCancelledError(
    
                    "ORDER_CANNOT_BE_CANCELLED",
                    "Order already shipped"
                )
            }
    
            this._status = "cancelled"
        }
    }

============================================================
FILE: ./src/app.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import express from "express"
    import cors from "cors"
    import authRoutes from "./routes/authRoutes"
    import cartRoutes from "./routes/cartRoutes"
    import productRoutes from "./routes/productRoutes"
    import adminRoutes from "./routes/adminRoutes"
    import userRoutes from "./routes/userRoutes"
    import orderRoutes from "./routes/orderRoutes"
    import addressRoutes from "./routes/addressRoutes"
    
    const app = express()
     
    // Middlewares
    app.use(cors())
    app.use(express.json())
    
    app.use("/api/admin", adminRoutes)
    app.use("/api/auth", authRoutes)
    app.use("/api/users", userRoutes)
    app.use("/api/cart", cartRoutes)
    app.use("/api/products", productRoutes)
    app.use("/api/orders", orderRoutes)
    app.use("/api/addresses", addressRoutes)
    
    export default app

============================================================
FILE: ./src/@types/express/index.d.ts
LAST_MODIFIED: 2025-12-28 17:22:13
============================================================

    import "express"
    
    declare module "express-serve-static-core" {
    
        interface Request {
    
            user?: {
                userId: string;
                role: "user" | "admin";
            };
        }
    }
    

============================================================
FILE: ./src/application/handlers/UpdateSalesMetricsHandler.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { DomainEventHandler } from "../../domain/events/DomainEventHandler"
    import { OrderCreatedEvent } from "../../domain/events/OrderCreatedEvent"
    
    export class UpdateSalesMetricsHandler
    implements DomainEventHandler<OrderCreatedEvent> {
    
        async handle(event: OrderCreatedEvent) {
            console.log(
                `[METRICS] Nova venda registrada: R$ ${event.total}`
            )
        }
    }

============================================================
FILE: ./src/application/handlers/SendOrderEmailHandler.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { DomainEventHandler } from "../../domain/events/DomainEventHandler"
    import { OrderCreatedEvent } from "../../domain/events/OrderCreatedEvent"
    
    export class SendOrderEmailHandler
    implements DomainEventHandler<OrderCreatedEvent> {
    
        async handle(event: OrderCreatedEvent) {
            console.log(
                `[EMAIL] Pedido ${event.orderId} criado para usu√°rio ${event.userId}`
            )
        }
    }

============================================================
FILE: ./src/application/usecases/ListMyOrdersUseCaseImpl.ts
LAST_MODIFIED: 2025-12-29 12:36:00
============================================================

    import {
        ListMyOrdersUseCase,
        ListMyOrdersInput,
        OrderSummary
    } from "./ListMyOrdersUseCase"
    
    import { OrderRepository } from "../ports/OrderRepository"
    
    export class ListMyOrdersUseCaseImpl
    implements ListMyOrdersUseCase {
    
        constructor(
            private readonly orderRepository: OrderRepository
        ) {}                                    
    
        async execute(
            { userId }: ListMyOrdersInput
        ): Promise<OrderSummary[]> {
    
            return this.orderRepository.findByUserId(userId)
        }
    }

============================================================
FILE: ./src/application/usecases/GetAllOrdersUseCase.ts
LAST_MODIFIED: 2025-12-29 13:58:09
============================================================

    export type OrderSummary = {
    
        id: string;
        userId: string;
        status: string;
        total: number;
        createdAt: Date;
    };
    
    export type GetAllOrdersInput = {
    
        actor: {
            id: string;
            role: "admin" | "user";
        };
    };
    
    export interface GetAllOrdersUseCase {
    
        execute(input: GetAllOrdersInput): Promise<OrderSummary[]>;
    }

============================================================
FILE: ./src/application/usecases/RemoveItemFromCartUseCaseImpl.ts
LAST_MODIFIED: 2025-12-29 06:57:59
============================================================

    import {
        RemoveItemFromCartUseCase,
        RemoveItemFromCartInput,
    } from "./RemoveItemFromCartUseCase"
    
    import { CartRepository } from "../ports/CartRepository"
    import { CartNotFoundError } from "../../domain/errors/CartNotFoundError"
    
    export class RemoveItemFromCartUseCaseImpl
    implements RemoveItemFromCartUseCase {
    
        constructor(
            private readonly cartRepository: CartRepository
        ) {}
    
        async execute( { userId, productId }: RemoveItemFromCartInput ): Promise<void> {
    
            const cart = await this.cartRepository.findByUserId(userId)
            if (!cart) {
                throw new CartNotFoundError(`Cart for user ${userId} not found`)
            }
            await this.cartRepository.removeItem(userId, productId)
        }
    }

============================================================
FILE: ./src/application/usecases/ClearCartUseCaseImpl.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { ClearCartUseCase, ClearCartInput } from "./ClearCartUseCase"
    import { CartRepository } from "../ports/CartRepository"
    
    export class ClearCartUseCaseImpl implements ClearCartUseCase {
    
        constructor(
            private readonly cartRepository: CartRepository
        ) {}
    
        async execute({ userId }: ClearCartInput): Promise<void> {
    
            const cart = await this.cartRepository.findByUserId(userId)
    
            // comportamento idempotente:
            // se o carrinho n√£o existe, n√£o √© erro
            if (!cart) {
                return
            }
    
            await this.cartRepository.clear(userId)
        }
    }

============================================================
FILE: ./src/application/usecases/RemoveItemFromCartUseCase.ts
LAST_MODIFIED: 2025-12-27 12:31:15
============================================================

    export type RemoveItemFromCartInput = {
        userId: string;
        productId: string;
    };
    
    export interface RemoveItemFromCartUseCase {
        execute(input: RemoveItemFromCartInput): Promise<void>;
    }

============================================================
FILE: ./src/application/usecases/UpdateOrderStatusUseCaseImpl.ts
LAST_MODIFIED: 2025-12-29 14:42:00
============================================================

    import {
        UpdateOrderStatusUseCase,
        UpdateOrderStatusInput,
        UpdateOrderStatusOutput
    } from "./UpdateOrderStatusUseCase"
    
    import { OrderRepository } from "../ports/OrderRepository"
    import { OrderStatusDomainService } from "../../domain/services/OrderStatusDomainService"
    import { OrderNotFoundError } from "../../domain/errors/OrderNotFoundError"
    
    export class UpdateOrderStatusUseCaseImpl
    implements UpdateOrderStatusUseCase {
    
        private readonly statusService = new OrderStatusDomainService()
    
        constructor(
            private readonly orderRepository: OrderRepository
        ) {}
    
        async execute(
            input: UpdateOrderStatusInput
        ): Promise<UpdateOrderStatusOutput> {
    
            const order = await this.orderRepository.findById(input.orderId)
    
            if (!order) {
                throw new OrderNotFoundError("Order not found")
            }
    
            this.statusService.validatePermission(
                input.actor.role,
                order.status,
                input.newStatus
            )
    
            this.statusService.validateTransition(
                order.status,
                input.newStatus
            )
    
            await this.orderRepository.updateStatus(
                order.id,
                input.newStatus
            )
    
            return {
                orderId: order.id,
                previousStatus: order.status,
                currentStatus: input.newStatus
            }
        }
    }

============================================================
FILE: ./src/application/usecases/UpdateOrderStatusUseCase.ts
LAST_MODIFIED: 2025-12-19 14:19:39
============================================================

    export type UpdateOrderStatusInput = {
        orderId: string;
        newStatus: string;
        actor: {
            id: string;
            role: "admin" | "user";
        };
    };
    
    export type UpdateOrderStatusOutput = {
        orderId: string;
        previousStatus: string;
        currentStatus: string;
    };
    
    export interface UpdateOrderStatusUseCase {
        execute(input: UpdateOrderStatusInput): Promise<UpdateOrderStatusOutput>;
    }

============================================================
FILE: ./src/application/usecases/ListMyOrdersUseCase.ts
LAST_MODIFIED: 2025-12-29 12:44:04
============================================================

    export type ListMyOrdersInput = {
        userId: string;
    };
    
    export type OrderSummary = {
        id: string;
        status: string;
        total: number;
        createdAt?: Date;
    };
    
    export interface ListMyOrdersUseCase {
        execute(input: ListMyOrdersInput): Promise<OrderSummary[]>;
    }

============================================================
FILE: ./src/application/usecases/CheckoutUseCase.ts
LAST_MODIFIED: 2025-12-29 12:44:24
============================================================

    export type CheckoutInput = {
    
        userId: string;
    };
    
    export type CheckoutOutput = {
    
        orderId: string;
        status: string;
        total: number;
    };
    
    export interface CheckoutUseCase {
    
        execute(input: CheckoutInput): Promise<CheckoutOutput>;
    }

============================================================
FILE: ./src/application/usecases/GetCartUseCaseImpl.ts
LAST_MODIFIED: 2025-12-22 12:37:19
============================================================

    import { GetCartUseCase, GetCartInput, CartOutput } from "./GetCartUseCase"
    import { CartRepository } from "../ports/CartRepository"
    
    export class GetCartUseCaseImpl
    implements GetCartUseCase {
    
        constructor(
    
            private readonly cartRepository: CartRepository
        ) {}
    
        async execute({ userId }: GetCartInput): Promise<CartOutput> {
    
            const cart = await this.cartRepository.findByUserId(userId)
    
            return {
    
                items: cart?.items ?? []
            }
        }
    }

============================================================
FILE: ./src/application/usecases/ClearCartUseCase.ts
LAST_MODIFIED: 2025-12-27 12:27:22
============================================================

    export type ClearCartInput = {
        userId: string;
    };
    
    export interface ClearCartUseCase {
        execute(input: ClearCartInput): Promise<void>;
    }

============================================================
FILE: ./src/application/usecases/GetAllOrdersUseCaseImpl.ts
LAST_MODIFIED: 2025-12-29 15:47:45
============================================================

    import {
        GetAllOrdersUseCase,
        GetAllOrdersInput,
        OrderSummary
    } from "./GetAllOrdersUseCase"
    
    import { OrderRepository } from "../ports/OrderRepository"
    import { AccessDeniedError } from "../../domain/errors/AccessDeniedError"
    
    export class GetAllOrdersUseCaseImpl
    implements GetAllOrdersUseCase {
    
        constructor(
    
            private readonly orderRepository: OrderRepository
        ) {}
    
        async execute(
            { actor }: GetAllOrdersInput
        ): Promise<OrderSummary[]> {
    
            if (actor.role !== "admin") {
                throw new AccessDeniedError("ACCESS_DENIED", "Access denied")
            }
    
            return this.orderRepository.findAll()
        }
    }

============================================================
FILE: ./src/application/usecases/AddItemToCartUseCaseImpl.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import {
        AddItemToCartUseCase,
        AddItemToCartInput,
    } from "./AddItemToCartUseCase"
    
    import { CartRepository } from "../ports/CartRepository"
    import { ProductRepository } from "../ports/ProductRepository"
    
    import { ProductNotFoundError } from "../../domain/errors/ProductNotFoundError"
    import { InsufficientStockError } from "../../domain/errors/CheckoutErrors"
    
    export class AddItemToCartUseCaseImpl implements AddItemToCartUseCase {
    
        constructor(
            private readonly cartRepository: CartRepository,
            private readonly productRepository: ProductRepository
        ) {}
    
        async execute({
            userId,
            productId,
            quantity,
        }: AddItemToCartInput): Promise<void> {
    
            // 1. Verificar se o produto existe
            const product = await this.productRepository.findById(productId)
    
            if (!product) {
                throw new ProductNotFoundError(productId)
            }
    
            // 2. Verificar estoque
            if (product.stock < quantity) {
                throw new InsufficientStockError(
                    productId,
                    product.stock,
                    quantity
                )
            }
    
            // 3. Delegar a persist√™ncia ao reposit√≥rio
            await this.cartRepository.addItem(
                userId,
                productId,
                quantity
            )
        }
    }

============================================================
FILE: ./src/application/usecases/GetCartUseCase.ts
LAST_MODIFIED: 2025-12-22 12:34:15
============================================================

    export type GetCartInput = {
    
        userId: string;
    };
    
    export type CartItemOutput = {
    
        productId: string;
        quantity: number;
    };
    
    export type CartOutput = {
    
        items: CartItemOutput[];
    };
    
    export interface GetCartUseCase {
    
        execute(input: GetCartInput): Promise<CartOutput>;
    }

============================================================
FILE: ./src/application/usecases/AddItemToCartUseCase.ts
LAST_MODIFIED: 2025-12-27 12:20:25
============================================================

    export type AddItemToCartInput = {
        userId: string;
        productId: string;
        quantity: number;
    };
    
    export interface AddItemToCartUseCase {
        execute(input: AddItemToCartInput): Promise<void>;
    }

============================================================
FILE: ./src/application/usecases/CheckoutUseCaseImpl.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { CheckoutUseCase } from "./CheckoutUseCase"
    import { CartRepository } from "../ports/CartRepository"
    import { ProductRepository } from "../ports/ProductRepository"
    import { OrderRepository } from "../ports/OrderRepository"
    import { TransactionManager } from "../ports/TransactionManager"
    import { ClearCartUseCase } from "./ClearCartUseCase"
    import { OutboxRepository } from "../ports/OutboxRepository"
    import { CartEmptyError } from "../../domain/errors/CheckoutErrors"
    import { OrderValidationService } from "../../domain/services/OrderValidationService"
    
    export class CheckoutUseCaseImpl implements CheckoutUseCase {
        constructor(
        private readonly cartRepository: CartRepository,
        private readonly productRepository: ProductRepository,
        private readonly orderRepository: OrderRepository,
        private readonly transactionManager: TransactionManager,
        private readonly clearCartUseCase: ClearCartUseCase,
        private readonly outboxRepository: OutboxRepository   // ‚úÖ novo par√¢metro
        ) {}
    
        async execute(input: { userId: string }): Promise<{ orderId: string; status: string; total: number }> {
            return this.transactionManager.runInTransaction(async () => {
                const cart = await this.cartRepository.findByUserId(input.userId)
                if (!cart || cart.items.length === 0) {
                    throw new CartEmptyError()
                }
    
                const products = await this.productRepository.findByIds(cart.items.map(i => i.productId))
                const total = new OrderValidationService().validateAndCalculateTotal(cart.items, products)
    
                for (const item of cart.items) {
                    await this.productRepository.decrementStock(item.productId, item.quantity)
                }
    
                const order = await this.orderRepository.create({
                    userId: input.userId,
                    items: cart.items,
                    total,
                    status: "pending",
                })
    
                await this.clearCartUseCase.execute({ userId: input.userId })
    
                // üî• Persistir evento no Outbox
                await this.outboxRepository.save({
                    name: "order.placed",
                    payload: {
                        orderId: order.id,
                        userId: input.userId,
                        total,
                    },
                    occurredAt: new Date(),
                })
    
                return { orderId: order.id, status: "pending", total }
            })
        }
    }

============================================================
FILE: ./src/application/events/ApplicationEvent.ts
LAST_MODIFIED: 2025-12-22 17:55:29
============================================================

    export interface ApplicationEvent {
    
        readonly name: string;
        readonly occurredAt: Date;
        readonly payload: unknown;
    }

============================================================
FILE: ./src/application/events/OrderPlacedEvent.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { ApplicationEvent } from "./ApplicationEvent"
    
    export class OrderPlacedEvent implements ApplicationEvent {
    
        readonly name = "order.placed"
        readonly occurredAt = new Date()
    
        constructor(
    
            public readonly payload: {
    
                orderId: string;
                userId: string;
                total: number;
            }
        ) {}
    }

============================================================
FILE: ./src/application/ports/OutboxRepository.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { ApplicationEvent } from "../events/ApplicationEvent"
    
    export interface OutboxRepository {
    
        save(event: ApplicationEvent): Promise<void>;
    }

============================================================
FILE: ./src/application/ports/TransactionManager.ts
LAST_MODIFIED: 2025-12-19 15:31:58
============================================================

    export interface TransactionManager {
        runInTransaction<T>(fn: () => Promise<T>): Promise<T>;
    }

============================================================
FILE: ./src/application/ports/CartRepository.ts
LAST_MODIFIED: 2025-12-27 12:11:57
============================================================

    export interface CartRepository {
    
      findByUserId(
        userId: string
      ): Promise<{
        userId: string;
        items: { productId: string; quantity: number }[];
      } | null>;
    
      addItem(
        userId: string,
        productId: string,
        quantity: number
      ): Promise<void>;
    
      removeItem(
        userId: string,
        productId: string
      ): Promise<void>;
    
      clear(
        userId: string
      ): Promise<void>;
    }

============================================================
FILE: ./src/application/ports/OrderRepository.ts
LAST_MODIFIED: 2025-12-29 14:58:25
============================================================

    export interface OrderRepository {
    
        findById(id: string): Promise<{
            id: string;
            userId: string;
            items: any[];
            total: number;
            status: string;
        } | null>;
    
        findByUserId(userId: string): Promise<{
            id: string;
            userId: string;
            items: any[];
            total: number;
            status: string;
        }[]>;
    
        findAll(): Promise<{
            id: string;
            userId: string;
            items: any[];
            total: number;
            status: string;
            createdAt: Date;
        }[]>;
    
        create(data: {
            userId: string;
            items: any[];
            total: number;
            status: string;
        }): Promise<{
            id: string;
            userId: string;
            items: any[];
            total: number;
            status: string;
        }>;
    
        updateStatus(id: string, status: string): Promise<{
            id: string;
            userId: string;
            items: any[];
            total: number;
            status: string;
        } | null>;
    
        create(order: any): Promise<any>; // Adiciona esta linha
    }

============================================================
FILE: ./src/application/ports/ProductRepository.ts
LAST_MODIFIED: 2025-12-22 13:57:09
============================================================

    export type ProductData = {
    
        id: string;
        price: number;
        stock: number;
    };
    
    export interface ProductRepository {
    
        findById(id: string): Promise<{
    
            id: string;
            stock: number;
        } | null>;
    
        findByIds(ids: string[]): Promise<ProductData[]>;
        decrementStock(productId: string, quantity: number): Promise<void>;
    }
    
    

============================================================
FILE: ./src/middlewares/adminAuth.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    // FILE: src/middlewares/adminAuth.ts
    
    import { Request, Response, NextFunction } from "express"
    
    export const adminAuth = (req: Request, res: Response, next: NextFunction)=> {
        // 1. Verifica se o usu√°rio foi autenticado
        if (!req.user || !req.user.role) {
            return res.status(401).json({ error: "Acesso negado. Token inv√°lido ou ausente." })
        }
        
        // 2. Verifica se o papel (role) √© 'admin'
        if (req.user.role !== "admin") {
            return res.status(403).json({ error: "Acesso negado. Requer permiss√£o de Administrador." })
        }
    
        next()
    }
============================================================
FILE: ./src/middlewares/authMiddleware.ts
LAST_MODIFIED: 2025-12-28 17:51:48
============================================================

    import { Request, Response, NextFunction } from "express"
    import jwt from "jsonwebtoken"
    
    export const authenticate = (req: Request, res: Response, next: NextFunction) => {
    
        const authHeader = req.headers.authorization
    
        if (!authHeader) {
            return res.status(401).json({ error: "Token n√£o fornecido" })
        }
    
        const token = authHeader.split(" ")[1]
    
        try {
    
            const decoded = jwt.verify(token, process.env.JWT_SECRET) as { userId: string; role: string }
            req.user = {
                userId: decoded.userId,
                role: decoded.role
            }
            next()
        }
    
        catch (err) {
            return res.status(401).json({ error: "Token inv√°lido" })
        }
    }
============================================================
FILE: ./src/middlewares/isAdmin.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { Request, Response, NextFunction } from "express"
    
    export const isAdmin = (
        req: Request,
        res: Response,
        next: NextFunction,
    ) => {
        if (!req.user) {
            return res.status(401).json({ error: "Usu√°rio n√£o autenticado" })
        }
    
        if (req.user.role !== "admin") {
            return res
                .status(403)
                .json({ error: "Acesso negado: apenas administradores" })
        }
    
        next()
    }

============================================================
FILE: ./src/routes/cartRoutes.ts
LAST_MODIFIED: 2025-12-28 17:10:55
============================================================

    import { Router } from "express"
    import { getCart, addItemToCart, removeItemFromCart, clearCart } from "../controllers/cartController"
    import { authenticate } from "../middlewares/authMiddleware" // Corrigido para plural
    
    const router = Router()
    
    router.get("/", authenticate, getCart)
    router.post("/add", authenticate, addItemToCart)
    router.post("/remove", authenticate, removeItemFromCart) // Corrigido nome da fun√ß√£o
    router.post("/clear", authenticate, clearCart)
    
    export default router
============================================================
FILE: ./src/routes/userRoutes.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { Router } from "express"
    import { authenticate } from "../middlewares/authMiddleware"
    import { isAdmin } from "../middlewares/isAdmin"
    import {
        getAllUsers,
        getUserById,
        updateUser,
        deleteUser,
    } from "../controllers/userController"
    
    const router = Router()
    
    // Todas as rotas de manipula√ß√£o de usu√°rios exigem Admin neste design
    router.get("/", authenticate, isAdmin, getAllUsers)
    router.get("/:id", authenticate, isAdmin, getUserById)
    router.put("/:id", authenticate, isAdmin, updateUser)
    router.delete("/:id", authenticate, isAdmin, deleteUser)
    
    export default router

============================================================
FILE: ./src/routes/authRoutes.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { Router } from "express"
    import { registerUser, loginUser } from "../controllers/authController"
    
    const router = Router()
    
    router.post("/register", registerUser)
    router.post("/login", loginUser)
    
    export default router
============================================================
FILE: ./src/routes/adminRoutes.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    import { Router } from "express"
    import { authenticate } from "../middlewares/authMiddleware"
    import { isAdmin } from "../middlewares/isAdmin"
    import { getStats } from "../controllers/adminController"
    
    const router = Router()
    
    router.get("/stats", authenticate, isAdmin, getStats)
    
    export default router

============================================================
FILE: ./src/routes/orderRoutes.ts
LAST_MODIFIED: 2025-12-28 13:50:58
============================================================

    import { Router } from "express"
    import { checkout, getMyOrders, updateOrderStatus, getAllOrders, createOrder } from "../controllers/orderController"
    import { authenticate } from "../middlewares/authMiddleware"
    
    const router = Router()
    
    router.post("/checkout", authenticate, checkout)
    router.post("/", authenticate, createOrder)
    router.get("/my", authenticate, getMyOrders)
    
    router.get("/", authenticate, getAllOrders)
    router.put("/:id", authenticate, updateOrderStatus)
    
    export default router
============================================================
FILE: ./src/routes/addressRoutes.ts
LAST_MODIFIED: 2025-12-28 17:07:56
============================================================

    import { Router } from "express"
    import { authenticate } from "../middlewares/authMiddleware" 
    import { 
        createAddress, 
        getAddresses, 
        updateAddress, 
        deleteAddress 
    } from "../controllers/addressController"
    
    const router = Router()
    
    // Todas as rotas de endere√ßo s√£o protegidas por autentica√ß√£o
    router.use(authenticate)
    
    // POST /api/addresses - Criar endere√ßo
    router.post("/", createAddress)
    
    // GET /api/addresses - Listar endere√ßos
    router.get("/", getAddresses)
    
    // PUT /api/addresses/:id - Atualizar endere√ßo
    router.put("/:id", updateAddress)
    
    // DELETE /api/addresses/:id - Deletar endere√ßo
    router.delete("/:id", deleteAddress)
    
    export default router
============================================================
FILE: ./src/routes/productRoutes.ts
LAST_MODIFIED: 2025-12-22 09:50:30
============================================================

    // FILE: src/routes/productRoutes.ts
    
    import { Router } from "express"
    import { authenticate } from "../middlewares/authMiddleware" 
    import { adminAuth } from "../middlewares/adminAuth" 
    import { 
        createProduct, 
        getAllProducts, 
        updateProduct, 
        deleteProduct 
    } from "../controllers/productController" // Importa a l√≥gica do controller
    
    const router = Router()
    
    // GET /api/products - Rota p√∫blica para listar todos os produtos
    router.get("/", getAllProducts)
    
    // Rotas protegidas (apenas Admin)
    // POST /api/products - Criar produto
    router.post("/", authenticate, adminAuth, createProduct)
    
    // PUT /api/products/:id - Atualizar produto
    router.put("/:id", authenticate, adminAuth, updateProduct)
    
    // DELETE /api/products/:id - Deletar produto
    router.delete("/:id", authenticate, adminAuth, deleteProduct)
    
    export default router
